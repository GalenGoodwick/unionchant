// Union Chant Database Schema
// Based on SPEC.md

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// ============ USERS ============

enum UserStatus {
  ACTIVE
  BANNED
  DELETED
}

enum UserRole {
  USER       // Regular user (default)
  MODERATOR  // Can moderate content, manage reports
  ADMIN      // Full system access
}

model User {
  id            String     @id @default(cuid())
  email         String     @unique
  name          String?
  image         String?
  bio           String?
  emailVerified DateTime?
  status        UserStatus @default(ACTIVE)
  role          UserRole   @default(USER)
  onboardedAt   DateTime?  // Set when user completes onboarding
  tutorialCompletedAt DateTime? // Set when user completes the world peace tutorial
  captchaVerifiedAt DateTime?  // Last CAPTCHA verification (valid for 24h)
  isAnonymous   Boolean    @default(false)      // Temporary anonymous account (auto-deleted after 24h)
  anonymousExpiresAt DateTime?                  // When to auto-delete this anonymous account
  isAI          Boolean    @default(false)      // AI persona for cold-start engagement
  aiPersonality String?                        // e.g. "methodical", "contrarian", "bridge-builder"
  theme         String     @default("system")  // "light", "dark", "system"
  emailNotifications Boolean @default(true)
  emailVoting        Boolean @default(true)   // Your turn to vote, voting ending soon
  emailResults       Boolean @default(true)   // Priority declared, idea advanced, tier complete
  emailSocial        Boolean @default(true)   // New followers, followed user creates talk
  emailCommunity     Boolean @default(true)   // Group invites, new talks in your groups
  emailNews          Boolean @default(true)   // Admin news/podium broadcasts
  zipCode         String?   // Optional, user-provided
  subscriptionTier   String  @default("free") // "free", "pro", "business", "scale"
  stripeCustomerId   String? @unique
  stripeSubscriptionId String?
  lastCollectiveTalkChangeAt DateTime? // Rate limit: free = 1 Talk change/day
  deletedAt     DateTime?
  botFlaggedAt  DateTime?  // Set when user fails runaway button challenge (insta-click)
  lastChallengePassedAt DateTime?  // Last time user passed a challenge
  challengeFailCount    Int        @default(0)  // Cumulative challenge failures
  bannedAt      DateTime?
  banReason     String?
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt

  // Auth relations
  accounts             Account[]
  sessions             Session[]
  webauthnCredentials  WebAuthnCredential[]

  // App relations
  deliberationsCreated Deliberation[]     @relation("Creator")
  memberships          DeliberationMember[]
  ideas                Idea[]
  cellParticipations   CellParticipation[]
  votes                Vote[]
  comments             Comment[]
  commentUpvotes       CommentUpvote[]
  pushSubscriptions    PushSubscription[]
  watches              Watch[]
  predictions          Prediction[]
  notifications        Notification[]

  // Community relations
  communitiesCreated   Community[]        @relation("CommunityCreator")
  communityMemberships CommunityMember[]

  // Agreement score relations
  agreementScoresA     AgreementScore[]   @relation("AgreementUserA")
  agreementScoresB     AgreementScore[]   @relation("AgreementUserB")

  // Moderation relations
  reportsCreated       Report[]           @relation("ReportsCreated")
  reportsResolved      Report[]           @relation("ReportsResolved")

  // Auth
  passwordHash  String?

  // Discord integration
  discordId     String?  @unique

  // Common Ground integration
  cgId          String?  @unique

  // Prediction stats (denormalized for fast leaderboard queries)
  totalPredictions     Int @default(0)
  correctPredictions   Int @default(0)
  championPicks        Int @default(0)  // Predicted idea that became champion
  currentStreak        Int @default(0)
  bestStreak           Int @default(0)

  // Follow relations
  followers     Follow[] @relation("Followers")
  following     Follow[] @relation("Following")

  // Podium relations
  podiums       Podium[]

  // AI Agent relation
  aiAgent       AIAgent?

  // Deliberation upvotes
  deliberationUpvotes DeliberationUpvote[]

  // Idea revision relations
  ideaRevisionsProposed IdeaRevision[]     @relation("RevisionProposer")
  ideaRevisionVotes     IdeaRevisionVote[] @relation("RevisionVoter")

  // Group chat
  groupMessages         GroupMessage[]      @relation("GroupMessages")

  // Community bans
  communityBans         CommunityBan[]      @relation("CommunityBans")
  communityBansMade     CommunityBan[]      @relation("CommunityBansMade")

  // Challenge logs
  challengeLogs         ChallengeLog[]

  // API keys
  apiKeys               ApiKey[]

  // Webhook integrations
  integrations          Integration[]

  // Crypto module (feature-flagged, removable)
  walletAddress         String?  @unique  // Solana wallet address
  boosts                Boost[]
  launchContributions   Contribution[]
  launchPoolsCreated    LaunchPool[]
}

// ============ NEXT-AUTH MODELS ============

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model WebAuthnCredential {
  id            String    @id @default(cuid())
  userId        String
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  credentialId  String    @unique
  publicKey     Bytes
  counter       BigInt    @default(0)
  transports    String[]  @default([])
  deviceName    String?
  createdAt     DateTime  @default(now())
  lastUsedAt    DateTime?

  @@index([userId])
}

// ============ DELIBERATION (ROOM) ============

model Deliberation {
  id          String   @id @default(cuid())
  creatorId   String
  creator     User     @relation("Creator", fields: [creatorId], references: [id])

  // Content
  question     String
  description  String?
  context      String?   // Evidence, links, background info — exempt from URL moderation
  organization String?   // Organization name (e.g., "Minneapolis Teachers Union")
  tags         String[]  @default([])

  // Invite
  inviteCode  String?  @unique

  // Settings
  submissionDurationMs  Int      @default(86400000)  // 24 hours
  votingTimeoutMs       Int      @default(3600000)   // 1 hour
  secondVoteTimeoutMs   Int      @default(900000)    // 15 minutes
  discussionDurationMs  Int?     // null = no discussion (skip to voting). e.g. 7200000 = 2h. -1 = manual advance only
  accumulationEnabled   Boolean  @default(false)
  accumulationTimeoutMs Int      @default(86400000)  // 24 hours
  continuousFlow        Boolean  @default(false)     // Tier 1: submit + vote in parallel; tier 2+: new ideas pool for next round
  submissionsClosed     Boolean  @default(false)     // Facilitator closed idea submissions (continuous flow)
  multipleIdeasAllowed  Boolean  @default(false)     // Allow multiple ideas per person (creator toggle)
  fastCell              Boolean  @default(false)     // Single cell, no tiers. 5 agents vote once, winner declared immediately. For arbitration/disputes.
  supermajorityEnabled  Boolean  @default(true)      // No-timer mode: auto-advance tier when 80%+ cells done (10min grace)
  allocationMode        String   @default("balanced") // "balanced" = random shuffle + conflict avoidance; "fcfs" = first-come-first-serve, no pre-assigned participants
  cellSize              Int      @default(5)          // Participants per cell (3-7). Default 5.
  allowAI               Boolean  @default(true)       // Whether AI agents (isAI=true) can join
  isPublic              Boolean  @default(true)

  // Goal-based auto-start (null = unlimited/manual start)
  ideaGoal        Int?     // Auto-start voting when this many ideas submitted
  memberGoal      Int?     // Auto-start voting when this many members joined (event mode)

  // State
  phase               Phase    @default(SUBMISSION)
  currentTier         Int      @default(1)
  currentTierStartedAt DateTime?  // When current voting tier started
  championId          String?  // ID of winning idea
  championEnteredTier Int?     // Tier champion enters in challenge
  challengeRound      Int      @default(0)  // Current challenge round number
  views               Int      @default(0)  // View count for social proof

  // Timestamps
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt
  submissionEndsAt    DateTime?
  completedAt         DateTime?
  accumulationEndsAt  DateTime? // When the accumulation period ends

  // Community FK
  communityId   String?
  community     Community?  @relation(fields: [communityId], references: [id], onDelete: SetNull)

  // Showcase flag (for AI-populated deliberation)
  isShowcase    Boolean  @default(false)
  // Created from collective chat (one per user)
  fromCollective Boolean @default(false)

  // Upvotes (collective priority)
  upvoteCount   Int      @default(0)

  // Featured/pinned chant (shown prominently, onboarding funnel target)
  isPinned      Boolean  @default(false)

  // Relations
  members       DeliberationMember[]
  ideas         Idea[]
  cells         Cell[]
  watchers      Watch[]
  predictions   Prediction[]
  podiums       Podium[]
  aiAgents      AIAgent[]
  upvotes       DeliberationUpvote[]

  // Crypto module (feature-flagged, removable)
  boosts        Boost[]
  launchPool    LaunchPool?

  @@index([creatorId])
  @@index([isPublic, phase])
  @@index([organization])
  @@index([communityId])
  @@index([submissionEndsAt])
  @@index([currentTierStartedAt])
  @@index([phase, createdAt])
}

// Tracks which Discord servers have loaded a chant (cross-server deliberation)

enum Phase {
  SUBMISSION
  VOTING
  COMPLETED
  ACCUMULATING
}

// ============ DELIBERATION MEMBERSHIP ============

model DeliberationMember {
  id              String   @id @default(cuid())
  deliberationId  String
  deliberation    Deliberation @relation(fields: [deliberationId], references: [id], onDelete: Cascade)
  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  role            MemberRole @default(PARTICIPANT)
  joinedAt        DateTime   @default(now())
  lastActiveAt    DateTime   @default(now())

  @@unique([deliberationId, userId])
  @@index([deliberationId])
  @@index([userId])
}

enum MemberRole {
  CREATOR
  PARTICIPANT
  SPECTATOR
}

// ============ IDEAS ============

model Idea {
  id              String   @id @default(cuid())
  deliberationId  String
  deliberation    Deliberation @relation(fields: [deliberationId], references: [id], onDelete: Cascade)
  authorId        String
  author          User     @relation(fields: [authorId], references: [id], onDelete: Cascade)

  text            String

  // State
  status          IdeaStatus @default(SUBMITTED)
  tier            Int        @default(0)
  isChampion      Boolean    @default(false)
  isNew           Boolean    @default(false)  // Submitted during accumulation
  losses          Int        @default(0)      // Track total losses (2 = eliminated)

  // Vote tracking
  totalVotes      Int        @default(0)   // count of unique voters
  totalXP         Int        @default(0)   // sum of all xpPoints

  createdAt       DateTime   @default(now())

  // Relations
  votes           Vote[]
  cellIdeas       CellIdea[]
  predictions     Prediction[]
  comments        Comment[]    // Comments linked to this idea (follow across tiers)
  revisions       IdeaRevision[]

  @@index([deliberationId])
  @@index([authorId])
  @@index([deliberationId, status])
}

enum IdeaStatus {
  SUBMITTED
  PENDING       // Ready to compete
  POOLED        // Lost once, back in pool for second chance
  IN_VOTING
  ADVANCING
  ELIMINATED    // Lost twice, out for good
  WINNER
  DEFENDING     // Champion in challenge
  BENCHED       // Has 2 losses but protected by minimum pool
  RETIRED       // Permanently eliminated
}

// ============ CELLS ============

model Cell {
  id              String   @id @default(cuid())
  deliberationId  String
  deliberation    Deliberation @relation(fields: [deliberationId], references: [id], onDelete: Cascade)

  tier            Int
  batch           Int?     // For Tier 2+ batching

  // State
  status          CellStatus @default(DELIBERATING)
  secondVotesEnabled Boolean @default(false)

  // Timing
  discussionEndsAt  DateTime? // when discussion period ends for this cell
  votingStartedAt   DateTime?
  votingDeadline    DateTime?
  secondVoteDeadline DateTime?
  finalizesAt       DateTime?  // Grace period: all votes in, finalizes at this time
  completedAt       DateTime?
  completedByTimeout Boolean @default(false)

  createdAt       DateTime @default(now())

  avgXPUtilization Float?    // average % of 10 XP used by participants

  // Relations
  participants    CellParticipation[]
  ideas           CellIdea[]
  votes           Vote[]
  comments        Comment[]
  predictions     Prediction[]
  ideaRevisions   IdeaRevision[]

  @@index([deliberationId, tier])
  @@index([deliberationId, status])
  @@index([status, finalizesAt])
  @@index([status, discussionEndsAt])
}

enum CellStatus {
  DELIBERATING
  VOTING
  COMPLETED
}

// Junction table for Cell <-> Idea (many-to-many)
model CellIdea {
  id       String @id @default(cuid())
  cellId   String
  cell     Cell   @relation(fields: [cellId], references: [id], onDelete: Cascade)
  ideaId   String
  idea     Idea   @relation(fields: [ideaId], references: [id], onDelete: Cascade)

  @@unique([cellId, ideaId])
  @@index([cellId])
  @@index([ideaId])
}

// ============ CELL PARTICIPATION ============

model CellParticipation {
  id              String   @id @default(cuid())
  cellId          String
  cell            Cell     @relation(fields: [cellId], references: [id], onDelete: Cascade)
  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  status          ParticipantStatus @default(ACTIVE)
  replacedById    String?  // If replaced, who took their spot

  joinedAt        DateTime @default(now())
  lastSeenAt      DateTime @default(now())
  votedAt         DateTime?
  droppedAt       DateTime?

  @@unique([cellId, userId])
  @@index([cellId])
  @@index([userId])
  @@index([cellId, status])
  @@index([userId, status])
}

enum ParticipantStatus {
  ACTIVE
  VOTED
  IDLE
  DROPPED
  REPLACED
}

// ============ VOTES ============

model Vote {
  id              String   @id @default(cuid())
  cellId          String
  cell            Cell     @relation(fields: [cellId], references: [id], onDelete: Cascade)
  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  ideaId          String
  idea            Idea     @relation(fields: [ideaId], references: [id], onDelete: Cascade)
  revisionId      String?                    // XP for an edit (null = original idea)

  xpPoints        Int      @default(10)      // 1-10 XP allocated to this idea
  isSecondVote    Boolean  @default(false)
  votedAt         DateTime @default(now())

  @@unique([cellId, userId, ideaId, revisionId]) // one allocation per user per idea/edit
  @@index([cellId])
  @@index([ideaId])
  @@index([cellId, userId])
}

// ============ COMMENTS ============

model Comment {
  id              String   @id @default(cuid())
  cellId          String
  cell            Cell     @relation(fields: [cellId], references: [id], onDelete: Cascade)
  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  ideaId          String?  // Optional: link comment to specific idea (follows idea across tiers)
  idea            Idea?    @relation(fields: [ideaId], references: [id], onDelete: SetNull)

  text            String
  replyToId       String?  // For threading
  replyTo         Comment? @relation("Replies", fields: [replyToId], references: [id], onDelete: SetNull)
  replies         Comment[] @relation("Replies")

  // Up-pollinate tracking
  views           Int      @default(0)       // How many people saw this
  reachTier       Int      @default(1)       // Current up-pollinate tier (1-9)
  upvoteCount     Int      @default(0)       // Denormalized for fast queries
  tierUpvotes     Int      @default(0)       // Upvotes in current reach tier (resets on tier change)
  spreadCount     Int      @default(0)       // How many same-tier cells this has spread to (0 = origin cell only)

  // Moderation
  isRemoved       Boolean  @default(false)   // Soft-deleted by author or moderator
  removedAt       DateTime?
  removedBy       String?                    // userId of who removed it

  createdAt       DateTime @default(now())

  // Relations
  upvotes         CommentUpvote[]

  @@index([cellId])
  @@index([userId])
  @@index([ideaId])
  @@index([cellId, reachTier])
}

// Track who upvoted which comment (for up-pollinate calculation)
model CommentUpvote {
  id              String   @id @default(cuid())
  commentId       String
  comment         Comment  @relation(fields: [commentId], references: [id], onDelete: Cascade)
  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt       DateTime @default(now())

  @@unique([commentId, userId])
  @@index([commentId])
  @@index([userId])
}

// ============ WATCHERS ============

model Watch {
  id              String       @id @default(cuid())
  userId          String
  user            User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  deliberationId  String
  deliberation    Deliberation @relation(fields: [deliberationId], references: [id], onDelete: Cascade)

  createdAt       DateTime     @default(now())

  @@unique([userId, deliberationId])
  @@index([deliberationId])
}

// ============ PUSH SUBSCRIPTIONS ============

model PushSubscription {
  id              String   @id @default(cuid())
  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  endpoint        String   @unique @db.Text  // Push endpoints can be very long
  p256dh          String   @db.Text          // Public key (base64)
  auth            String   @db.Text          // Auth secret (base64)

  createdAt       DateTime @default(now())
  lastUsedAt      DateTime @default(now())

  @@index([userId])
}

// ============ PREDICTIONS ============

model Prediction {
  id              String   @id @default(cuid())
  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  deliberationId  String
  deliberation    Deliberation @relation(fields: [deliberationId], references: [id], onDelete: Cascade)

  // What they predicted
  cellId          String?  // For Tier 1 cell-level predictions (null for batch predictions)
  cell            Cell?    @relation(fields: [cellId], references: [id], onDelete: Cascade)
  tierPredictedAt Int      // Which tier they made this prediction
  predictedIdeaId String   // The idea they think will win
  predictedIdea   Idea     @relation(fields: [predictedIdeaId], references: [id], onDelete: Cascade)

  // Outcome - tracks the idea's full journey
  wonImmediate    Boolean? // Did idea win this cell/batch? (null until resolved)
  ideaFinalTier   Int?     // Highest tier the idea reached
  ideaBecameChampion Boolean? // Did this idea become THE champion?
  resolvedAt      DateTime?

  // Engagement
  enteredForVoting Boolean @default(false)  // Did they jump in to vote after predicting?
  createdAt       DateTime @default(now())

  @@unique([userId, cellId])  // One prediction per cell (Tier 1)
  @@unique([userId, deliberationId, tierPredictedAt], map: "unique_batch_prediction")  // One per batch (Tier 2+)
  @@index([deliberationId, tierPredictedAt])
  @@index([userId])
  @@index([predictedIdeaId])  // For updating when idea status changes
}

// ============ NOTIFICATIONS ============

model Notification {
  id              String   @id @default(cuid())
  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  type            NotificationType
  title           String
  body            String?

  // Context - what triggered this notification
  // NOTE: These are raw IDs without FK relations to avoid orphan issues with existing data.
  // When querying, check if the referenced entity still exists.
  deliberationId  String?
  cellId          String?
  commentId       String?
  ideaId          String?
  communityId     String?

  // State
  read            Boolean  @default(false)
  readAt          DateTime?

  createdAt       DateTime @default(now())

  @@index([userId, read])
  @@index([userId, createdAt])
}

enum NotificationType {
  COMMENT_REPLY        // Someone replied to your comment
  COMMENT_UPVOTE       // Someone upvoted your comment
  COMMENT_UP_POLLINATE // Your comment reached a new tier
  COMMENT_DEMOTED      // Your comment dropped a tier (didn't maintain engagement)
  IDEA_ADVANCING       // Your idea is advancing
  IDEA_WON             // Your idea won
  VOTE_NEEDED          // Your cell needs your vote
  DELIBERATION_UPDATE  // General deliberation update
  COMMUNITY_INVITE     // Invited to a community
  COMMUNITY_NEW_DELIB  // New deliberation in a community you belong to
  FOLLOW               // Someone followed you
  FOLLOWED_NEW_DELIB   // Someone you follow created a new deliberation
  FOLLOWED_VOTED       // Someone you follow voted in a deliberation you're not in
  CONTENT_REMOVED      // Your content was removed by a moderator
  COMMUNITY_BAN        // You banned a user from a group
  PODIUM_NEWS          // Admin news broadcast via podium
  ADMIN_CHALLENGE      // Admin triggered mass challenge
}

// ============ COMMUNITIES ============

enum CommunityRole {
  OWNER
  ADMIN
  MEMBER
}

model Community {
  id          String   @id @default(cuid())
  name        String
  slug        String   @unique
  description String?
  image       String?
  isPublic    Boolean  @default(true)
  inviteCode  String?  @unique

  // Who can create deliberations: "anyone", "admins", or "role"
  postingPermission String @default("anyone")
  chantRoleId       String?  // Discord role ID when postingPermission == "role"
  defaultChantId    String?  // Currently active default chant for this server

  creatorId   String
  creator     User     @relation("CommunityCreator", fields: [creatorId], references: [id])

  // Discord integration
  discordGuildId    String? @unique
  discordInviteUrl  String?
  discordChannelId  String?  // Announcement channel for bot auto-posts

  // Common Ground integration
  cgCommunityId     String? @unique

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  members       CommunityMember[]
  deliberations Deliberation[]
  chatMessages  GroupMessage[]
  bans          CommunityBan[]

  @@index([creatorId])
  @@index([isPublic])
}

model CommunityMember {
  id            String         @id @default(cuid())
  communityId   String
  community     Community      @relation(fields: [communityId], references: [id], onDelete: Cascade)
  userId        String
  user          User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  role          CommunityRole  @default(MEMBER)
  joinedAt      DateTime       @default(now())
  lastActiveAt  DateTime       @default(now())

  @@unique([communityId, userId])
  @@index([communityId])
  @@index([userId])
}

// ============ FOLLOWS ============

model Follow {
  id          String   @id @default(cuid())
  followerId  String
  follower    User     @relation("Following", fields: [followerId], references: [id], onDelete: Cascade)
  followingId String
  following   User     @relation("Followers", fields: [followingId], references: [id], onDelete: Cascade)
  createdAt   DateTime @default(now())

  @@unique([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
}

// ============ AGREEMENT SCORES ============

model AgreementScore {
  id            String   @id @default(cuid())
  userAId       String
  userA         User     @relation("AgreementUserA", fields: [userAId], references: [id], onDelete: Cascade)
  userBId       String
  userB         User     @relation("AgreementUserB", fields: [userBId], references: [id], onDelete: Cascade)
  agreeCount    Int      @default(0)
  disagreeCount Int      @default(0)
  totalCells    Int      @default(0)
  updatedAt     DateTime @updatedAt

  @@unique([userAId, userBId])
  @@index([userAId])
  @@index([userBId])
}

// ============ REPORTS / MODERATION ============

model Report {
  id            String       @id @default(cuid())
  reporterId    String
  reporter      User         @relation("ReportsCreated", fields: [reporterId], references: [id], onDelete: Cascade)

  // What's being reported
  targetType    ReportTarget
  targetId      String       // ID of the reported entity

  reason        ReportReason
  details       String?      // Optional description from reporter

  // Resolution
  status        ReportStatus @default(PENDING)
  resolvedById  String?
  resolvedBy    User?        @relation("ReportsResolved", fields: [resolvedById], references: [id], onDelete: SetNull)
  resolvedAt    DateTime?
  resolution    String?      // What action was taken

  createdAt     DateTime     @default(now())

  @@index([status])
  @@index([targetType, targetId])
  @@index([reporterId])
}

enum ReportTarget {
  COMMENT
  IDEA
  DELIBERATION
  USER
}

enum ReportReason {
  SPAM
  HARASSMENT
  HATE_SPEECH
  MISINFORMATION
  INAPPROPRIATE
  OTHER
}

enum ReportStatus {
  PENDING
  RESOLVED
  DISMISSED
}

// ============ RATE LIMIT CONFIG ============


// ============ PODIUM (LONG-FORM WRITING) ============

model Podium {
  id              String   @id @default(cuid())
  title           String
  body            String   @db.Text
  authorId        String
  author          User     @relation(fields: [authorId], references: [id], onDelete: Cascade)

  // Optional link to deliberation (cross-linking)
  deliberationId  String?
  deliberation    Deliberation? @relation(fields: [deliberationId], references: [id], onDelete: SetNull)

  views           Int      @default(0)
  pinned          Boolean  @default(false)

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([authorId])
  @@index([deliberationId])
  @@index([createdAt])
}

// ============ CRON EXECUTION LOG ============

model CronLog {
  id          String    @id @default(cuid())
  startedAt   DateTime  @default(now())
  completedAt DateTime?
  trigger     String    // 'vercel_cron' | 'external_cron' | 'feed_api' | 'lazy_eval'
  success     Boolean   @default(true)
  error       String?
  processed   Int       @default(0)
  durationMs  Int?

  @@index([startedAt])
}

// ============ AI AGENTS ============

model AIAgent {
  id              String   @id @default(cuid())
  userId          String   @unique
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  deliberationId  String
  deliberation    Deliberation @relation(fields: [deliberationId], references: [id], onDelete: Cascade)
  persona         String   // "optimist", "skeptic", "pragmatist", etc.
  personalityDesc String   @db.Text // full personality prompt for Haiku
  createdOrder    Int      // 1-100, lower = replaced last
  isRetired       Boolean  @default(false)
  retiredByUserId String?  // human who replaced this agent
  isCollective    Boolean  @default(false) // the one agent that can't be replaced
  hasSubmittedIdea Boolean @default(false)
  lastActionAt    DateTime?
  nextActionAfter DateTime? // stagger actions
  createdAt       DateTime @default(now())

  @@index([deliberationId, isRetired])
  @@index([nextActionAfter])
}

// ============ COLLECTIVE CHAT ============

// ============ DELIBERATION UPVOTES ============

model DeliberationUpvote {
  id              String   @id @default(cuid())
  deliberationId  String
  deliberation    Deliberation @relation(fields: [deliberationId], references: [id], onDelete: Cascade)
  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt       DateTime @default(now())

  @@unique([deliberationId, userId])
  @@index([deliberationId])
  @@index([userId])
}

// ============ IDEA REVISIONS ============

model IdeaRevision {
  id           String   @id @default(cuid())
  ideaId       String
  idea         Idea     @relation(fields: [ideaId], references: [id], onDelete: Cascade)
  proposedText String
  proposedById String
  proposedBy   User     @relation("RevisionProposer", fields: [proposedById], references: [id])
  status       String   @default("pending")  // "pending" | "approved" | "rejected"
  approvals    Int      @default(0)
  required     Int                            // total cell members needed (unanimous)
  cellId       String
  cell         Cell     @relation(fields: [cellId], references: [id], onDelete: Cascade)
  createdAt    DateTime @default(now())

  votes        IdeaRevisionVote[]

  @@index([ideaId])
  @@index([cellId])
}

model IdeaRevisionVote {
  id         String   @id @default(cuid())
  revisionId String
  revision   IdeaRevision @relation(fields: [revisionId], references: [id], onDelete: Cascade)
  userId     String
  user       User     @relation("RevisionVoter", fields: [userId], references: [id])
  approve    Boolean
  createdAt  DateTime @default(now())

  @@unique([revisionId, userId])
}

model CollectiveMessage {
  id        String   @id @default(cuid())
  role      String   // "user" | "assistant"
  content   String   @db.Text
  userName  String?  // display name of human sender
  userId    String?  // null for anonymous
  model     String   @default("haiku") // "haiku" | "sonnet" | "opus"
  isPrivate Boolean  @default(false) // true = only visible to sender (tune-out mode)
  replyToUserId String? // for assistant messages: which user this reply is for
  createdAt DateTime @default(now())

  @@index([createdAt])
  @@index([userId, isPrivate])
  @@index([userId, createdAt])
}

model CommunityBan {
  id          String    @id @default(cuid())
  communityId String
  community   Community @relation(fields: [communityId], references: [id], onDelete: Cascade)
  userId      String
  user        User      @relation("CommunityBans", fields: [userId], references: [id], onDelete: Cascade)
  bannedById  String
  bannedBy    User      @relation("CommunityBansMade", fields: [bannedById], references: [id])
  reason      String?
  createdAt   DateTime  @default(now())

  @@unique([communityId, userId])
  @@index([communityId])
  @@index([userId])
}

model GroupMessage {
  id          String    @id @default(cuid())
  communityId String
  community   Community @relation(fields: [communityId], references: [id], onDelete: Cascade)
  userId      String
  user        User      @relation("GroupMessages", fields: [userId], references: [id], onDelete: Cascade)
  text        String    @db.Text
  createdAt   DateTime  @default(now())

  @@index([communityId, createdAt])
}

// ============ CHALLENGE LOG ============

model ChallengeLog {
  id              String   @id @default(cuid())
  userId          String?
  user            User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  result          String   // "pending", "passed", "failed_insta_click", "failed_no_chase", "failed_validation", "failed_replay", "expired"
  pointerEvents   Int      @default(0)
  chaseDurationMs Int      @default(0)
  evadeCount      Int      @default(0)
  surrendered     Boolean  @default(false)
  chasePath       Json?    // [{x,y,t}] sampled pointer path for behavioral fingerprinting
  challengeToken  String?  @unique // crypto nonce, one-time use
  issuedAt        DateTime? // when challenge was shown to user
  pathHash        String?  // SHA-256 of rounded coordinate sequence for replay detection
  used            Boolean  @default(false) // consumed on completion
  createdAt       DateTime @default(now())

  @@index([userId, createdAt])
  @@index([pathHash])
}

// ============ API KEYS ============

model ApiKey {
  id          String    @id @default(cuid())
  name        String                            // "Claude", "Enterprise Dev", etc.
  keyHash     String    @unique                 // SHA-256 hash of the raw key
  keyPrefix   String                            // First 8 chars for display ("uc_ak_a1...")
  userId      String                            // Owner who created the key
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  scopes      String[]  @default(["read", "write"])
  lastUsedAt  DateTime?
  expiresAt   DateTime?                         // null = never expires
  createdAt   DateTime  @default(now())

  @@index([userId])
}

// ============ WEBHOOK INTEGRATIONS ============

model Integration {
  id           String    @id @default(cuid())
  name         String                            // "AgentMemory", "SlotScribe"
  webhookUrl   String                            // Where to POST events
  secret       String                            // HMAC secret for signature verification
  events       String[]                          // ["idea_submitted","vote_cast","tier_complete","winner_declared"]
  enabled      Boolean   @default(true)
  userId       String                            // Owner (who registered it)
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  lastCalledAt DateTime?
  failCount    Int       @default(0)             // Auto-disable after 10 consecutive failures
  createdAt    DateTime  @default(now())

  @@index([userId])
}

// ============ CRYPTO MODULE (pluggable, feature-flagged) ============

enum LaunchStatus {
  FUNDING        // Accepting SOL contributions
  DELIBERATING   // UC cells voting on proposals
  DISTRIBUTING   // Winner declared, funds being sent
  COMPLETE       // Done
  CANCELLED      // Refunded
}

model Boost {
  id              String   @id @default(cuid())
  deliberationId  String
  deliberation    Deliberation @relation(fields: [deliberationId], references: [id], onDelete: Cascade)
  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  amountLamports  BigInt              // SOL amount in lamports (1 SOL = 1e9 lamports)
  txSignature     String?  @unique   // Solana tx signature (null = honor system / Phase 1)
  verified        Boolean  @default(false) // On-chain verification (Phase 2)
  createdAt       DateTime @default(now())

  @@index([deliberationId])
  @@index([userId])
}

model LaunchPool {
  id               String       @id @default(cuid())
  deliberationId   String       @unique  // 1:1 with deliberation — the chant IS the launch
  deliberation     Deliberation @relation(fields: [deliberationId], references: [id], onDelete: Cascade)
  creatorId        String
  creator          User         @relation(fields: [creatorId], references: [id], onDelete: Cascade)
  targetLamports   BigInt                 // Funding goal in lamports
  currentLamports  BigInt       @default(0)
  treasuryAddress  String?               // Solana escrow address (Phase 2)
  status           LaunchStatus @default(FUNDING)
  winnerIdeaId     String?               // UC idea that won deliberation
  poolDeadline     DateTime              // When funding period ends
  createdAt        DateTime     @default(now())
  updatedAt        DateTime     @updatedAt

  contributions    Contribution[]

  @@index([creatorId])
  @@index([status])
}

model Contribution {
  id             String    @id @default(cuid())
  launchPoolId   String
  launchPool     LaunchPool @relation(fields: [launchPoolId], references: [id], onDelete: Cascade)
  userId         String
  user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  amountLamports BigInt
  txSignature    String?   @unique  // Solana tx (Phase 2; Phase 1 = honor system)
  verified       Boolean   @default(false)
  createdAt      DateTime  @default(now())

  @@index([launchPoolId])
  @@index([userId])
}
