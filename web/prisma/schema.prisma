// Union Chant Database Schema
// Based on SPEC.md

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// ============ USERS ============

enum UserStatus {
  ACTIVE
  BANNED
  DELETED
}

enum UserRole {
  USER       // Regular user (default)
  MODERATOR  // Can moderate content, manage reports
  ADMIN      // Full system access
}

model User {
  id            String     @id @default(cuid())
  email         String     @unique
  name          String?
  image         String?
  bio           String?
  emailVerified DateTime?
  status        UserStatus @default(ACTIVE)
  role          UserRole   @default(USER)
  onboardedAt   DateTime?  // Set when user completes onboarding
  captchaVerifiedAt DateTime?  // Last CAPTCHA verification (valid for 24h)
  theme         String     @default("system")  // "light", "dark", "system"
  deletedAt     DateTime?
  bannedAt      DateTime?
  banReason     String?
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt

  // Auth relations
  accounts      Account[]
  sessions      Session[]

  // App relations
  deliberationsCreated Deliberation[]     @relation("Creator")
  memberships          DeliberationMember[]
  ideas                Idea[]
  cellParticipations   CellParticipation[]
  votes                Vote[]
  comments             Comment[]
  commentUpvotes       CommentUpvote[]
  pushSubscriptions    PushSubscription[]
  watches              Watch[]
  predictions          Prediction[]
  notifications        Notification[]

  // Community relations
  communitiesCreated   Community[]        @relation("CommunityCreator")
  communityMemberships CommunityMember[]

  // Auth
  passwordHash  String?

  // Prediction stats (denormalized for fast leaderboard queries)
  totalPredictions     Int @default(0)
  correctPredictions   Int @default(0)
  championPicks        Int @default(0)  // Predicted idea that became champion
  currentStreak        Int @default(0)
  bestStreak           Int @default(0)

  // Follow relations
  followers     Follow[] @relation("Followers")
  following     Follow[] @relation("Following")
}

// ============ NEXT-AUTH MODELS ============

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// ============ DELIBERATION (ROOM) ============

model Deliberation {
  id          String   @id @default(cuid())
  creatorId   String
  creator     User     @relation("Creator", fields: [creatorId], references: [id])

  // Content
  question     String
  description  String?
  organization String?   // Organization name (e.g., "Minneapolis Teachers Union")
  tags         String[]  @default([])

  // Invite
  inviteCode  String?  @unique

  // Settings
  submissionDurationMs  Int      @default(86400000)  // 24 hours
  votingTimeoutMs       Int      @default(3600000)   // 1 hour
  secondVoteTimeoutMs   Int      @default(900000)    // 15 minutes
  accumulationEnabled   Boolean  @default(true)
  accumulationTimeoutMs Int      @default(86400000)  // 24 hours
  isPublic              Boolean  @default(true)

  // Goal-based auto-start (null = unlimited/manual start)
  ideaGoal        Int?     // Auto-start voting when this many ideas submitted

  // State
  phase               Phase    @default(SUBMISSION)
  currentTier         Int      @default(1)
  currentTierStartedAt DateTime?  // When current voting tier started
  championId          String?  // ID of winning idea
  championEnteredTier Int?     // Tier champion enters in challenge
  challengeRound      Int      @default(0)  // Current challenge round number
  views               Int      @default(0)  // View count for social proof

  // Timestamps
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt
  submissionEndsAt    DateTime?
  completedAt         DateTime?
  accumulationEndsAt  DateTime? // When the accumulation period ends

  // Community FK
  communityId   String?
  community     Community?  @relation(fields: [communityId], references: [id], onDelete: SetNull)

  // Relations
  members       DeliberationMember[]
  ideas         Idea[]
  cells         Cell[]
  watchers      Watch[]
  predictions   Prediction[]

  @@index([creatorId])
  @@index([isPublic, phase])
  @@index([organization])
  @@index([communityId])
  @@index([submissionEndsAt])
  @@index([currentTierStartedAt])
  @@index([phase, createdAt])
}

enum Phase {
  SUBMISSION
  VOTING
  COMPLETED
  ACCUMULATING
}

// ============ DELIBERATION MEMBERSHIP ============

model DeliberationMember {
  id              String   @id @default(cuid())
  deliberationId  String
  deliberation    Deliberation @relation(fields: [deliberationId], references: [id], onDelete: Cascade)
  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  role            MemberRole @default(PARTICIPANT)
  joinedAt        DateTime   @default(now())
  lastActiveAt    DateTime   @default(now())

  @@unique([deliberationId, userId])
  @@index([deliberationId])
  @@index([userId])
}

enum MemberRole {
  CREATOR
  PARTICIPANT
  SPECTATOR
}

// ============ IDEAS ============

model Idea {
  id              String   @id @default(cuid())
  deliberationId  String
  deliberation    Deliberation @relation(fields: [deliberationId], references: [id], onDelete: Cascade)
  authorId        String
  author          User     @relation(fields: [authorId], references: [id])

  text            String

  // State
  status          IdeaStatus @default(SUBMITTED)
  tier            Int        @default(0)
  isChampion      Boolean    @default(false)
  isNew           Boolean    @default(false)  // Submitted during accumulation
  losses          Int        @default(0)      // Track total losses (2 = eliminated)

  // Vote tracking
  totalVotes      Int        @default(0)

  createdAt       DateTime   @default(now())

  // Relations
  votes           Vote[]
  cellIdeas       CellIdea[]
  predictions     Prediction[]
  comments        Comment[]    // Comments linked to this idea (follow across tiers)

  @@index([deliberationId])
  @@index([authorId])
  @@index([deliberationId, status])
}

enum IdeaStatus {
  SUBMITTED
  PENDING       // Ready to compete
  POOLED        // Lost once, back in pool for second chance
  IN_VOTING
  ADVANCING
  ELIMINATED    // Lost twice, out for good
  WINNER
  DEFENDING     // Champion in challenge
  BENCHED       // Has 2 losses but protected by minimum pool
  RETIRED       // Permanently eliminated
}

// ============ CELLS ============

model Cell {
  id              String   @id @default(cuid())
  deliberationId  String
  deliberation    Deliberation @relation(fields: [deliberationId], references: [id], onDelete: Cascade)

  tier            Int
  batch           Int?     // For Tier 2+ batching

  // State
  status          CellStatus @default(DELIBERATING)
  secondVotesEnabled Boolean @default(false)

  // Timing
  votingStartedAt   DateTime?
  votingDeadline    DateTime?
  secondVoteDeadline DateTime?
  finalizesAt       DateTime?  // Grace period: all votes in, finalizes at this time
  completedAt       DateTime?
  completedByTimeout Boolean @default(false)

  createdAt       DateTime @default(now())

  // Relations
  participants    CellParticipation[]
  ideas           CellIdea[]
  votes           Vote[]
  comments        Comment[]
  predictions     Prediction[]

  @@index([deliberationId, tier])
  @@index([deliberationId, status])
}

enum CellStatus {
  DELIBERATING
  VOTING
  COMPLETED
}

// Junction table for Cell <-> Idea (many-to-many)
model CellIdea {
  id       String @id @default(cuid())
  cellId   String
  cell     Cell   @relation(fields: [cellId], references: [id], onDelete: Cascade)
  ideaId   String
  idea     Idea   @relation(fields: [ideaId], references: [id], onDelete: Cascade)

  @@unique([cellId, ideaId])
  @@index([cellId])
  @@index([ideaId])
}

// ============ CELL PARTICIPATION ============

model CellParticipation {
  id              String   @id @default(cuid())
  cellId          String
  cell            Cell     @relation(fields: [cellId], references: [id], onDelete: Cascade)
  userId          String
  user            User     @relation(fields: [userId], references: [id])

  status          ParticipantStatus @default(ACTIVE)
  replacedById    String?  // If replaced, who took their spot

  joinedAt        DateTime @default(now())
  lastSeenAt      DateTime @default(now())
  votedAt         DateTime?
  droppedAt       DateTime?

  @@unique([cellId, userId])
  @@index([cellId])
  @@index([userId])
  @@index([cellId, status])
  @@index([userId, status])
}

enum ParticipantStatus {
  ACTIVE
  VOTED
  IDLE
  DROPPED
  REPLACED
}

// ============ VOTES ============

model Vote {
  id              String   @id @default(cuid())
  cellId          String
  cell            Cell     @relation(fields: [cellId], references: [id], onDelete: Cascade)
  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  ideaId          String
  idea            Idea     @relation(fields: [ideaId], references: [id], onDelete: Cascade)

  isSecondVote    Boolean  @default(false)
  votedAt         DateTime @default(now())

  @@unique([cellId, userId, isSecondVote])
  @@index([cellId])
  @@index([ideaId])
}

// ============ COMMENTS ============

model Comment {
  id              String   @id @default(cuid())
  cellId          String
  cell            Cell     @relation(fields: [cellId], references: [id], onDelete: Cascade)
  userId          String
  user            User     @relation(fields: [userId], references: [id])
  ideaId          String?  // Optional: link comment to specific idea (follows idea across tiers)
  idea            Idea?    @relation(fields: [ideaId], references: [id], onDelete: SetNull)

  text            String
  replyToId       String?  // For threading
  replyTo         Comment? @relation("Replies", fields: [replyToId], references: [id])
  replies         Comment[] @relation("Replies")

  // Up-pollinate tracking
  views           Int      @default(0)       // How many people saw this
  reachTier       Int      @default(1)       // Current up-pollinate tier (1-9)
  upvoteCount     Int      @default(0)       // Denormalized for fast queries
  tierUpvotes     Int      @default(0)       // Upvotes in current reach tier (resets on tier change)

  createdAt       DateTime @default(now())

  // Relations
  upvotes         CommentUpvote[]

  @@index([cellId])
  @@index([userId])
  @@index([ideaId])
  @@index([cellId, reachTier])
}

// Track who upvoted which comment (for up-pollinate calculation)
model CommentUpvote {
  id              String   @id @default(cuid())
  commentId       String
  comment         Comment  @relation(fields: [commentId], references: [id], onDelete: Cascade)
  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt       DateTime @default(now())

  @@unique([commentId, userId])
  @@index([commentId])
  @@index([userId])
}

// ============ WATCHERS ============

model Watch {
  id              String       @id @default(cuid())
  userId          String
  user            User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  deliberationId  String
  deliberation    Deliberation @relation(fields: [deliberationId], references: [id], onDelete: Cascade)

  createdAt       DateTime     @default(now())

  @@unique([userId, deliberationId])
  @@index([deliberationId])
}

// ============ PUSH SUBSCRIPTIONS ============

model PushSubscription {
  id              String   @id @default(cuid())
  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  endpoint        String   @unique @db.Text  // Push endpoints can be very long
  p256dh          String   @db.Text          // Public key (base64)
  auth            String   @db.Text          // Auth secret (base64)

  createdAt       DateTime @default(now())
  lastUsedAt      DateTime @default(now())

  @@index([userId])
}

// ============ PREDICTIONS ============

model Prediction {
  id              String   @id @default(cuid())
  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  deliberationId  String
  deliberation    Deliberation @relation(fields: [deliberationId], references: [id], onDelete: Cascade)

  // What they predicted
  cellId          String?  // For Tier 1 cell-level predictions (null for batch predictions)
  cell            Cell?    @relation(fields: [cellId], references: [id], onDelete: Cascade)
  tierPredictedAt Int      // Which tier they made this prediction
  predictedIdeaId String   // The idea they think will win
  predictedIdea   Idea     @relation(fields: [predictedIdeaId], references: [id], onDelete: Cascade)

  // Outcome - tracks the idea's full journey
  wonImmediate    Boolean? // Did idea win this cell/batch? (null until resolved)
  ideaFinalTier   Int?     // Highest tier the idea reached
  ideaBecameChampion Boolean? // Did this idea become THE champion?
  resolvedAt      DateTime?

  // Engagement
  enteredForVoting Boolean @default(false)  // Did they jump in to vote after predicting?
  createdAt       DateTime @default(now())

  @@unique([userId, cellId])  // One prediction per cell (Tier 1)
  @@unique([userId, deliberationId, tierPredictedAt], map: "unique_batch_prediction")  // One per batch (Tier 2+)
  @@index([deliberationId, tierPredictedAt])
  @@index([userId])
  @@index([predictedIdeaId])  // For updating when idea status changes
}

// ============ NOTIFICATIONS ============

model Notification {
  id              String   @id @default(cuid())
  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  type            NotificationType
  title           String
  body            String?

  // Context - what triggered this notification
  // NOTE: These are raw IDs without FK relations to avoid orphan issues with existing data.
  // When querying, check if the referenced entity still exists.
  deliberationId  String?
  cellId          String?
  commentId       String?
  ideaId          String?
  communityId     String?

  // State
  read            Boolean  @default(false)
  readAt          DateTime?

  createdAt       DateTime @default(now())

  @@index([userId, read])
  @@index([userId, createdAt])
}

enum NotificationType {
  COMMENT_REPLY        // Someone replied to your comment
  COMMENT_UPVOTE       // Someone upvoted your comment
  COMMENT_UP_POLLINATE // Your comment reached a new tier
  COMMENT_DEMOTED      // Your comment dropped a tier (didn't maintain engagement)
  IDEA_ADVANCING       // Your idea is advancing
  IDEA_WON             // Your idea won
  VOTE_NEEDED          // Your cell needs your vote
  DELIBERATION_UPDATE  // General deliberation update
  COMMUNITY_INVITE     // Invited to a community
  COMMUNITY_NEW_DELIB  // New deliberation in a community you belong to
  FOLLOW               // Someone followed you
}

// ============ COMMUNITIES ============

enum CommunityRole {
  OWNER
  ADMIN
  MEMBER
}

model Community {
  id          String   @id @default(cuid())
  name        String
  slug        String   @unique
  description String?
  image       String?
  isPublic    Boolean  @default(true)
  inviteCode  String?  @unique

  // Who can create deliberations: "anyone" (any member) or "admins" (owner+admin only)
  postingPermission String @default("anyone")

  creatorId   String
  creator     User     @relation("CommunityCreator", fields: [creatorId], references: [id])

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  members       CommunityMember[]
  deliberations Deliberation[]

  @@index([creatorId])
  @@index([isPublic])
}

model CommunityMember {
  id            String         @id @default(cuid())
  communityId   String
  community     Community      @relation(fields: [communityId], references: [id], onDelete: Cascade)
  userId        String
  user          User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  role          CommunityRole  @default(MEMBER)
  joinedAt      DateTime       @default(now())
  lastActiveAt  DateTime       @default(now())

  @@unique([communityId, userId])
  @@index([communityId])
  @@index([userId])
}

// ============ FOLLOWS ============

model Follow {
  id          String   @id @default(cuid())
  followerId  String
  follower    User     @relation("Following", fields: [followerId], references: [id], onDelete: Cascade)
  followingId String
  following   User     @relation("Followers", fields: [followingId], references: [id], onDelete: Cascade)
  createdAt   DateTime @default(now())

  @@unique([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
}

// ============ AGREEMENT SCORES ============

model AgreementScore {
  id            String   @id @default(cuid())
  userAId       String
  userBId       String
  agreeCount    Int      @default(0)
  disagreeCount Int      @default(0)
  totalCells    Int      @default(0)
  updatedAt     DateTime @updatedAt

  @@unique([userAId, userBId])
  @@index([userAId])
  @@index([userBId])
}

// ============ RATE LIMIT CONFIG ============

model RateLimitConfig {
  id          String   @id @default(cuid())
  endpoint    String   @unique  // e.g. "vote", "idea", "signup", "deliberation"
  maxRequests Int      @default(10)
  windowMs    Int      @default(60000)  // Window in milliseconds
  keyType     String   @default("userId")  // "userId" or "ip"
  enabled     Boolean  @default(true)
  updatedAt   DateTime @updatedAt
}
