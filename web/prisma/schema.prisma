// Union Chant Database Schema
// Based on SPEC.md

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// ============ USERS ============

enum UserStatus {
  ACTIVE
  BANNED
  DELETED
}

enum UserRole {
  USER       // Regular user (default)
  MODERATOR  // Can moderate content, manage reports
  ADMIN      // Full system access
}

model User {
  id            String     @id @default(cuid())
  email         String     @unique
  name          String?
  image         String?
  emailVerified DateTime?
  status        UserStatus @default(ACTIVE)
  role          UserRole   @default(USER)
  deletedAt     DateTime?
  bannedAt      DateTime?
  banReason     String?
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt

  // Auth relations
  accounts      Account[]
  sessions      Session[]

  // App relations
  deliberationsCreated Deliberation[]     @relation("Creator")
  memberships          DeliberationMember[]
  ideas                Idea[]
  cellParticipations   CellParticipation[]
  votes                Vote[]
  comments             Comment[]
  pushSubscriptions    PushSubscription[]
  watches              Watch[]
  predictions          Prediction[]

  // Prediction stats (denormalized for fast leaderboard queries)
  totalPredictions     Int @default(0)
  correctPredictions   Int @default(0)
  championPicks        Int @default(0)  // Predicted idea that became champion
  currentStreak        Int @default(0)
  bestStreak           Int @default(0)
}

// ============ NEXT-AUTH MODELS ============

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// ============ DELIBERATION (ROOM) ============

model Deliberation {
  id          String   @id @default(cuid())
  creatorId   String
  creator     User     @relation("Creator", fields: [creatorId], references: [id])

  // Content
  question    String
  description String?
  tags        String[]  @default([])

  // Invite
  inviteCode  String?  @unique

  // Settings
  submissionDurationMs  Int      @default(86400000)  // 24 hours
  votingTimeoutMs       Int      @default(3600000)   // 1 hour
  secondVoteTimeoutMs   Int      @default(900000)    // 15 minutes
  accumulationEnabled   Boolean  @default(true)
  accumulationTimeoutMs Int      @default(86400000)  // 24 hours
  isPublic              Boolean  @default(true)

  // Goal-based auto-start (null = unlimited/manual start)
  ideaGoal        Int?     // Auto-start voting when this many ideas submitted
  participantGoal Int?     // Auto-start voting when this many participants join

  // Meta-deliberation fields
  type              DeliberationType @default(STANDARD)
  spawnedFromId     String?          // Parent meta-deliberation
  spawnedFrom       Deliberation?    @relation("SpawnedFrom", fields: [spawnedFromId], references: [id])
  spawnedChildren   Deliberation[]   @relation("SpawnedFrom")
  autoJoinVoters    Boolean          @default(false)  // Join voters for winning idea

  // For recurring meta-deliberations
  isRecurring       Boolean          @default(false)
  recurringSchedule String?          // e.g., "daily", "weekly"
  nextOccurrence    DateTime?

  // State
  phase               Phase    @default(SUBMISSION)
  currentTier         Int      @default(1)
  championId          String?  // ID of winning idea
  championEnteredTier Int?     // Tier champion enters in challenge
  challengeRound      Int      @default(0)  // Current challenge round number

  // Timestamps
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt
  submissionEndsAt    DateTime?
  completedAt         DateTime?
  accumulationEndsAt  DateTime? // When the accumulation period ends

  // Relations
  members     DeliberationMember[]
  ideas       Idea[]
  cells       Cell[]
  watchers    Watch[]
  predictions Prediction[]

  @@index([creatorId])
  @@index([isPublic, phase])
  @@index([type])
}

enum Phase {
  SUBMISSION
  VOTING
  COMPLETED
  ACCUMULATING
}

enum DeliberationType {
  STANDARD      // Normal deliberation
  META          // "What should we decide next?"
  SPAWNED       // Auto-created from meta winner
}

// ============ DELIBERATION MEMBERSHIP ============

model DeliberationMember {
  id              String   @id @default(cuid())
  deliberationId  String
  deliberation    Deliberation @relation(fields: [deliberationId], references: [id], onDelete: Cascade)
  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  role            MemberRole @default(PARTICIPANT)
  joinedAt        DateTime   @default(now())
  lastActiveAt    DateTime   @default(now())

  @@unique([deliberationId, userId])
  @@index([deliberationId])
  @@index([userId])
}

enum MemberRole {
  CREATOR
  PARTICIPANT
  SPECTATOR
}

// ============ IDEAS ============

model Idea {
  id              String   @id @default(cuid())
  deliberationId  String
  deliberation    Deliberation @relation(fields: [deliberationId], references: [id], onDelete: Cascade)
  authorId        String
  author          User     @relation(fields: [authorId], references: [id])

  text            String

  // State
  status          IdeaStatus @default(SUBMITTED)
  tier            Int        @default(0)
  isChampion      Boolean    @default(false)
  isNew           Boolean    @default(false)  // Submitted during accumulation
  losses          Int        @default(0)      // Track total losses (2 = eliminated)

  // Vote tracking
  totalVotes      Int        @default(0)

  createdAt       DateTime   @default(now())

  // Relations
  votes           Vote[]
  cellIdeas       CellIdea[]
  predictions     Prediction[]

  @@index([deliberationId])
  @@index([authorId])
  @@index([deliberationId, status])
}

enum IdeaStatus {
  SUBMITTED
  PENDING       // Ready to compete
  POOLED        // Lost once, back in pool for second chance
  IN_VOTING
  ADVANCING
  ELIMINATED    // Lost twice, out for good
  WINNER
  DEFENDING     // Champion in challenge
  BENCHED       // Has 2 losses but protected by minimum pool
  RETIRED       // Permanently eliminated
}

// ============ CELLS ============

model Cell {
  id              String   @id @default(cuid())
  deliberationId  String
  deliberation    Deliberation @relation(fields: [deliberationId], references: [id], onDelete: Cascade)

  tier            Int
  batch           Int?     // For Tier 2+ batching

  // State
  status          CellStatus @default(DELIBERATING)
  secondVotesEnabled Boolean @default(false)

  // Timing
  votingStartedAt   DateTime?
  votingDeadline    DateTime?
  secondVoteDeadline DateTime?
  completedAt       DateTime?
  completedByTimeout Boolean @default(false)

  createdAt       DateTime @default(now())

  // Relations
  participants    CellParticipation[]
  ideas           CellIdea[]
  votes           Vote[]
  comments        Comment[]
  predictions     Prediction[]

  @@index([deliberationId, tier])
  @@index([deliberationId, status])
}

enum CellStatus {
  DELIBERATING
  VOTING
  COMPLETED
}

// Junction table for Cell <-> Idea (many-to-many)
model CellIdea {
  id       String @id @default(cuid())
  cellId   String
  cell     Cell   @relation(fields: [cellId], references: [id], onDelete: Cascade)
  ideaId   String
  idea     Idea   @relation(fields: [ideaId], references: [id], onDelete: Cascade)

  @@unique([cellId, ideaId])
  @@index([cellId])
  @@index([ideaId])
}

// ============ CELL PARTICIPATION ============

model CellParticipation {
  id              String   @id @default(cuid())
  cellId          String
  cell            Cell     @relation(fields: [cellId], references: [id], onDelete: Cascade)
  userId          String
  user            User     @relation(fields: [userId], references: [id])

  status          ParticipantStatus @default(ACTIVE)
  replacedById    String?  // If replaced, who took their spot

  joinedAt        DateTime @default(now())
  lastSeenAt      DateTime @default(now())
  votedAt         DateTime?
  droppedAt       DateTime?

  @@unique([cellId, userId])
  @@index([cellId])
  @@index([userId])
  @@index([cellId, status])
}

enum ParticipantStatus {
  ACTIVE
  VOTED
  IDLE
  DROPPED
  REPLACED
}

// ============ VOTES ============

model Vote {
  id              String   @id @default(cuid())
  cellId          String
  cell            Cell     @relation(fields: [cellId], references: [id], onDelete: Cascade)
  userId          String
  user            User     @relation(fields: [userId], references: [id])
  ideaId          String
  idea            Idea     @relation(fields: [ideaId], references: [id])

  isSecondVote    Boolean  @default(false)
  votedAt         DateTime @default(now())

  @@unique([cellId, userId, isSecondVote])
  @@index([cellId])
  @@index([ideaId])
}

// ============ COMMENTS ============

model Comment {
  id              String   @id @default(cuid())
  cellId          String
  cell            Cell     @relation(fields: [cellId], references: [id], onDelete: Cascade)
  userId          String
  user            User     @relation(fields: [userId], references: [id])

  text            String
  replyToId       String?  // For threading
  replyTo         Comment? @relation("Replies", fields: [replyToId], references: [id])
  replies         Comment[] @relation("Replies")

  createdAt       DateTime @default(now())

  @@index([cellId])
  @@index([userId])
}

// ============ WATCHERS ============

model Watch {
  id              String       @id @default(cuid())
  userId          String
  user            User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  deliberationId  String
  deliberation    Deliberation @relation(fields: [deliberationId], references: [id], onDelete: Cascade)

  createdAt       DateTime     @default(now())

  @@unique([userId, deliberationId])
  @@index([deliberationId])
}

// ============ PUSH SUBSCRIPTIONS ============

model PushSubscription {
  id              String   @id @default(cuid())
  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  endpoint        String   @unique @db.Text  // Push endpoints can be very long
  p256dh          String   @db.Text          // Public key (base64)
  auth            String   @db.Text          // Auth secret (base64)

  createdAt       DateTime @default(now())
  lastUsedAt      DateTime @default(now())

  @@index([userId])
}

// ============ PREDICTIONS ============

model Prediction {
  id              String   @id @default(cuid())
  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  deliberationId  String
  deliberation    Deliberation @relation(fields: [deliberationId], references: [id], onDelete: Cascade)

  // What they predicted
  cellId          String?  // For Tier 1 cell-level predictions (null for batch predictions)
  cell            Cell?    @relation(fields: [cellId], references: [id], onDelete: Cascade)
  tierPredictedAt Int      // Which tier they made this prediction
  predictedIdeaId String   // The idea they think will win
  predictedIdea   Idea     @relation(fields: [predictedIdeaId], references: [id], onDelete: Cascade)

  // Outcome - tracks the idea's full journey
  wonImmediate    Boolean? // Did idea win this cell/batch? (null until resolved)
  ideaFinalTier   Int?     // Highest tier the idea reached
  ideaBecameChampion Boolean? // Did this idea become THE champion?
  resolvedAt      DateTime?

  // Engagement
  enteredForVoting Boolean @default(false)  // Did they jump in to vote after predicting?
  createdAt       DateTime @default(now())

  @@unique([userId, cellId])  // One prediction per cell (Tier 1)
  @@unique([userId, deliberationId, tierPredictedAt], map: "unique_batch_prediction")  // One per batch (Tier 2+)
  @@index([deliberationId, tierPredictedAt])
  @@index([userId])
  @@index([predictedIdeaId])  // For updating when idea status changes
}
